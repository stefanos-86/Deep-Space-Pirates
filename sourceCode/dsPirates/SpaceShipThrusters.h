#pragma once

#include "ForceGenerator.h"
#include "TorqueGenerator.h"

#include "dsMath.h"

/**This is an helper object to simulate the spaceship manouvering system.
It can be considered as exposing two interfaces: one towards the logic, that can switch on and off the
engines, the other toward the physics, that can read forces and torques generated by the engines.

Weak point: where can we put the "main engine" in such a scheme?--> use a force generator that add up the main engine thrust.
*/

class SpaceShipThrusters : public ForceGenerator, public TorqueGenerator
{
private:
	/*The following values represent the forces and torques generated by the engine.
	The names are a bit "arcane", but those are the standard in rocket engineering.*/
	float T;	//traslation, X axis
	float Y;	//traslation, Y axis
	float Z;	//traslation, Z axis
	float A;	//roll
	float E;	//pitch
	float R;	//yaw

	/*Here we store the "power" of the engines: higher values means faster movement (mass and inertia being equal)*/
	float translationForce;
	float rotationTorque;



public:
	/**Initialize the system with the maximum power available.*/
	SpaceShipThrusters(const float force, const float torque);
	virtual ~SpaceShipThrusters();

	/*The thruster can expose those functionalities: the possible movements*/
	void forward();
	void reverse();
	void up();
	void down();
	void left();
	void right();
	void rollLeft();
	void rollRight();
	void pitchUp();
	void pitchDown();
	void yawLeft();
	void yawRight();
	void switchOff();

	/*This object can give input to the physics*/
	virtual Vector3d getForce();
	virtual Vector3d getTorque();

	/*A more compact interface*/
	enum nozzles {ROLL_L, ROLL_R, PITCH_U, PITCH_D, YAW_L, YAW_R, FORWARD, BACWARD, LEFT, RIGHT, UP, DOWN};
	void on(nozzles n);
	void off(nozzles n);

private:
	void nozzleActuation(nozzles n, float force);
};

