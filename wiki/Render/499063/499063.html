<div class="wikidoc">This is the part of the game that converts user input into game events. Here we deal with people bashing into the keyboard.<br />
<h2>Goal</h2>The input subsystem must:
<ul><li>allow the configuration of key bynding (user can customize)</li>
<li>be flexible
<ul><li>we do not know what the user controls will be (what the player will do in the game, and as such which keys he will press)</li>
<li>we do not know what will be on the &quot;receiving side&quot; of the input (what game objects are controlled by the user)</li></ul></li></ul>

<h2>Architecture</h2>The bottom layer is the OIS system provided with OGRE. We get the &quot;raw&quot; input (key pressure, mouse movement...) from there. The input mapper is our listener, and has to &quot;find the meaning&quot; of what it receives. That is, map the input to something meaningful for the game.<br /><br />A bit of &quot;glossary&quot;:<br />*Action: something meaningful in the game world that the player can do (&quot;fire the gun&quot;).<br />*Input mapper: is the thingy that transfors raw input (&quot;spacebar pressed&quot;) to the correnspondent action(&quot;fire the gun&quot;).<br />*Action executor or provider: a software object that contains the code to implement an action (&quot;gun.fire()&quot;).<br /><br />We use a plugin architecture. Actions are provided by game objects (using components). The game objects register its actions (&quot;I can fire a gun...&quot;) and provides the plugin to implement them (&quot;...call this software object to fire it&quot;). The input mapper knows the related key (&quot;fire a gun: press spacebar&quot;), looks up at runtime the executor and calls it.<br /><br />The binding between action and key can be changed at runtime. The executor of an action is &quot;fixed&quot; and can&#39;t be changed after the registration (this may change if needed - a way of un-registering plugin and dealing with no-more-available actions would be required).<br />If the action starts when the key is pressed and stops when it is released (&quot;fire the machine-gun&quot;) then two separate actions have to be recorded (&quot;press trigger&quot;/&quot;release trigger&quot;); there may be a single executor for both, however. This really depends on the plugin writer.<br /><br />The InputMapper is NOT responsible for the life of the plugins. It will not delete them.<br />
<h2>In the code...</h2>The interface of actions plugin is defined in the ActionProviderPlugin class. Extends this one to create a plugin.<br />The type for action names is ActionName (typedef to string).<br />The input mapper method registerActionsProvider cares of the registration. It calls declareActions in the plugin to get the actions that it provides.<br />The action-key binding is managed by the input mapper (keyToAction map). In the configuration file there are entries that link action names to key names. Those are loaded like any other property. The input mapper has a table that maps the key names to the OIS key codes (the key names are used only in the config file). On creation it scans the program options from the configuration store and for each key name that it finds it looks up the matching key code. Finally it stores the key code/action pair.<br />This system can be overriden in the code using the registerActionKey(key code, action name) method.<br />
<h2>What is left to do</h2>In the future (and on a &quot;if-needed&quot; basis):<br />*mouse support<br />*key combo support<br />*ctrl, alt, shift...<br />*extension for AI/network support? We could send requests to perform actions from the AI or the network and use the executors for non-player objects (is this the best way? Is this too fine-grained?)<br />*plugin de-registration</div><div class="ClearBoth"></div>